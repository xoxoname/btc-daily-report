# report_generators/regular_report.py
from .base_generator import BaseReportGenerator
from .mental_care import MentalCareGenerator
import traceback
from datetime import datetime, timedelta
import json
import pytz

class RegularReportGenerator(BaseReportGenerator):
    """Ï†ïÍ∏∞ Î¶¨Ìè¨Ìä∏ - ÏÑ†Î¨º Î°±/Ïàè ÌåêÎã® ÌäπÌôî"""
    
    def __init__(self, config, data_collector, indicator_system, bitget_client=None):
        super().__init__(config, data_collector, indicator_system, bitget_client)
        self.mental_care = MentalCareGenerator(self.openai_client)
        self.last_prediction = None
    
    async def generate_report(self) -> str:
        """üßæ ÏÑ†Î¨º Î°±/Ïàè ÌåêÎã® Ï¢ÖÌï© Î¶¨Ìè¨Ìä∏"""
        try:
            current_time = self._get_current_time_kst()
            
            # Ìè¨Í¥ÑÏ†Å Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            market_data = await self._collect_all_data()
            
            # Ï∂îÍ∞Ä ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            if self.data_collector:
                comprehensive_data = await self.data_collector.get_comprehensive_market_data()
                market_data.update(comprehensive_data)
            
            # ÏßÄÌëú ÏãúÏä§ÌÖú ÏÑ§Ï†ï
            if self.bitget_client and hasattr(self.indicator_system, 'set_bitget_client'):
                self.indicator_system.set_bitget_client(self.bitget_client)
            
            # ÏÑ†Î¨º ÌäπÌôî ÏßÄÌëú Í≥ÑÏÇ∞
            indicators = await self.indicator_system.calculate_all_indicators(market_data)
            
            # ÏÑπÏÖòÎ≥Ñ ÏÉùÏÑ±
            events_text = await self._format_market_events(market_data)
            futures_analysis = await self._format_futures_analysis(market_data, indicators)
            technical_text = await self._format_technical_analysis(market_data, indicators)
            sentiment_text = await self._format_market_sentiment(market_data, indicators)
            signal_text = self._format_trading_signals(indicators)
            strategy_text = await self._format_strategy_recommendation(market_data, indicators)
            risk_text = self._format_risk_assessment(indicators)
            validation_text = self._format_validation()
            pnl_text = await self._format_profit_loss()
            mental_text = await self._generate_mental_care(market_data, indicators)
            
            # Ïù¥Î≤à ÏòàÏ∏° Ï†ÄÏû•
            self._save_prediction(indicators)
            
            report = f"""üßæ ÎπÑÌä∏ÏΩîÏù∏ ÏÑ†Î¨º Î°±/Ïàè Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏
üìÖ ÏûëÏÑ± ÏãúÍ∞Å: {current_time} (KST)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìå ÏãúÏû• Ïù¥Î≤§Ìä∏ Î∞è Ï£ºÏöî ÏÜçÎ≥¥
{events_text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìä ÏÑ†Î¨º ÏãúÏû• ÌïµÏã¨ ÏßÄÌëú
{futures_analysis}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìâ Í∏∞Ïà†Ï†Å Î∂ÑÏÑù
{technical_text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üß† ÏãúÏû• Ïã¨Î¶¨ Î∞è Ìè¨ÏßÄÏÖîÎãù
{sentiment_text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üéØ Î°±/Ïàè Ïã†Ìò∏ Î∂ÑÏÑù
{signal_text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìå Ï†ÑÎûµ Ï†úÏïà
{strategy_text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ö†Ô∏è Î¶¨Ïä§ÌÅ¨ ÌèâÍ∞Ä
{risk_text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìä ÏòàÏ∏° Í≤ÄÏ¶ù
{validation_text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üí∞ ÏÜêÏùµ ÌòÑÌô©
{pnl_text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üß† Î©òÌÉà ÏºÄÏñ¥
{mental_text}"""
            
            return report
            
        except Exception as e:
            self.logger.error(f"Ï†ïÍ∏∞ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")
            self.logger.error(f"ÏÉÅÏÑ∏ Ïò§Î•ò: {traceback.format_exc()}")
            return f"‚ùå Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    async def _format_market_events(self, market_data: dict) -> str:
        """ÏãúÏû• Ïù¥Î≤§Ìä∏ - ÏÑ†Î¨º ÏòÅÌñ•ÎèÑ Ï§ëÏã¨ (ÌòïÏãù ÏàòÏ†ï)"""
        try:
            recent_news = await self.data_collector.get_recent_news(hours=6)
            
            if not recent_news:
                return """‚Ä¢ ÌòÑÏû¨ Ï£ºÏöî ÏãúÏû• Ïù¥Î≤§Ìä∏ ÏóÜÏùå ‚Üí Í∏∞Ïà†Ï†Å ÌùêÎ¶Ñ Ï£ºÎèÑ
- ÌéÄÎî©ÎπÑÏôÄ Ìè¨ÏßÄÏÖîÎãù Ï§ëÏã¨ÏúºÎ°ú ÌåêÎã® ÌïÑÏöî"""
            
            formatted = []
            kst = pytz.timezone('Asia/Seoul')
            
            for news in recent_news[:4]:  # ÏÉÅÏúÑ 4Í∞úÎßå
                # ÏãúÍ∞Ñ ÌòïÏãù Ï≤òÎ¶¨
                try:
                    if news.get('published_at'):
                        pub_time_str = news.get('published_at', '').replace('Z', '+00:00')
                        if 'T' in pub_time_str:
                            pub_time = datetime.fromisoformat(pub_time_str)
                        else:
                            from dateutil import parser
                            pub_time = parser.parse(pub_time_str)
                        
                        # KSTÎ°ú Î≥ÄÌôò
                        pub_time_kst = pub_time.astimezone(kst)
                        time_str = pub_time_kst.strftime('%m-%d %H:%M')
                    else:
                        time_str = datetime.now(kst).strftime('%m-%d %H:%M')
                except:
                    time_str = datetime.now(kst).strftime('%m-%d %H:%M')
                
                # ÌïúÍ∏Ä Ï†úÎ™© Ïö∞ÏÑ† ÏÇ¨Ïö©
                title = news.get('title_ko', news.get('title', '')).strip()[:80]
                
                # ÏÑ†Î¨º ÏãúÏû• ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
                futures_impact = await self._analyze_futures_impact(title)
                
                # ÌòïÏãù: ÏãúÍ∞Ñ "Ï†úÎ™©" ‚Üí ÏòÅÌñ•
                formatted.append(f"{time_str} \"{title}\" ‚Üí {futures_impact}")
            
            return '\n'.join(formatted) if formatted else "‚Ä¢ ÌäπÏù¥ Îâ¥Ïä§ ÏóÜÏùå"
            
        except Exception as e:
            self.logger.error(f"Îâ¥Ïä§ Ìè¨Îß∑ÌåÖ Ïò§Î•ò: {e}")
            return "‚Ä¢ Îâ¥Ïä§ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë Ïò§Î•ò"
    
    async def _analyze_futures_impact(self, title: str) -> str:
        """Îâ¥Ïä§Ïùò ÏÑ†Î¨º ÏãúÏû• ÏòÅÌñ• Î∂ÑÏÑù"""
        title_lower = title.lower()
        
        # ÏÑ†Î¨º ÏãúÏû• ÌäπÌôî ÌÇ§ÏõåÎìú
        if any(word in title_lower for word in ['etf', 'institutional', 'adoption', 'ÏäπÏù∏', 'Ï±ÑÌÉù', 'Í∏∞Í¥Ä']):
            return "‚ûïÌò∏Ïû¨ ÏòàÏÉÅ"
        elif any(word in title_lower for word in ['regulation', 'ban', 'investigation', 'Í∑úÏ†ú', 'Í∏àÏßÄ', 'Ï°∞ÏÇ¨']):
            return "‚ûñÏïÖÏû¨ ÏòàÏÉÅ"
        elif any(word in title_lower for word in ['fed', 'rate', 'inflation', 'Ïó∞Ï§Ä', 'Í∏àÎ¶¨', 'Ïù∏ÌîåÎ†à']):
            return "Ï§ëÎ¶Ω (Î≥ÄÎèôÏÑ± Ï£ºÏùò)"
        elif any(word in title_lower for word in ['liquidation', 'margin call', 'Ï≤≠ÏÇ∞', 'ÎßàÏßÑÏΩú']):
            return "‚ûñÏïÖÏû¨ ÏòàÏÉÅ"
        else:
            return "Ï§ëÎ¶Ω"
    
    async def _format_futures_analysis(self, market_data: dict, indicators: dict) -> str:
        """ÏÑ†Î¨º ÏãúÏû• ÌïµÏã¨ ÏßÄÌëú"""
        current_price = market_data.get('current_price', 0)
        
        # Í∞Å Î∂ÑÏÑù Í≤∞Í≥º Í∞ÄÏ†∏Ïò§Í∏∞
        funding = indicators.get('funding_analysis', {})
        oi = indicators.get('oi_analysis', {})
        basis = indicators.get('futures_metrics', {}).get('basis', {})
        ls_ratio = indicators.get('long_short_ratio', {})
        liquidations = indicators.get('liquidation_analysis', {})
        
        lines = [
            f"‚Ä¢ ÌòÑÏû¨Í∞Ä: ${current_price:,.0f} (Bitget BTCUSDT)",
            f"‚Ä¢ ÌéÄÎî©ÎπÑ: {funding.get('current_rate', 0):+.3%} (Ïó∞ÌôòÏÇ∞ {funding.get('annual_rate', 0):+.1f}%) ‚Üí {funding.get('signal', 'Ï§ëÎ¶Ω')}",
            f"‚Ä¢ ÎØ∏Í≤∞Ï†úÏïΩÏ†ï: {oi.get('oi_change_percent', 0):+.1f}% Î≥ÄÌôî ‚Üí {oi.get('price_divergence', 'Ï§ëÎ¶Ω')}",
            f"‚Ä¢ ÏÑ†Î¨º Î≤†Ïù¥ÏãúÏä§: {basis.get('rate', 0):+.3f}% ‚Üí {basis.get('signal', 'Ï§ëÎ¶Ω')}",
            f"‚Ä¢ Î°±/Ïàè ÎπÑÏú®: {ls_ratio.get('long_ratio', 50):.0f}:{ls_ratio.get('short_ratio', 50):.0f} ‚Üí {ls_ratio.get('signal', 'Í∑†Ìòï')}",
            f"‚Ä¢ Ï≤≠ÏÇ∞ ÏúÑÌóò: {liquidations.get('liquidation_pressure', 'Ï§ëÎ¶Ω')}"
        ]
        
        # Fear & Greed Index Ï∂îÍ∞Ä
        if 'fear_greed' in market_data and market_data['fear_greed']:
            fng = market_data['fear_greed']
            lines.append(f"‚Ä¢ Í≥µÌè¨ÌÉêÏöïÏßÄÏàò: {fng.get('value', 50)}/100 ({fng.get('value_classification', 'Neutral')})")
        
        # Ï¢ÖÌï© ÌèâÍ∞Ä Ï∂îÍ∞Ä
        lines.append("")
        lines.append(self._generate_futures_summary(indicators))
        
        return '\n'.join(lines)
    
    def _generate_futures_summary(self, indicators: dict) -> str:
        """ÏÑ†Î¨º ÏßÄÌëú Ï¢ÖÌï© ÌèâÍ∞Ä"""
        composite = indicators.get('composite_signal', {})
        signal = composite.get('signal', 'Ï§ëÎ¶Ω')
        
        if 'Í∞ïÌïú Î°±' in signal:
            return "ÌïµÏã¨ ÏßÄÌëú Î∂ÑÏÑù Ï¢ÖÌï© ÌèâÍ∞Ä ÏöîÏïΩ: ÌéÄÎî©ÎπÑ ÏïàÏ†ïÏ†ÅÏù¥Í≥† Îß§Ïàò ÏïïÎ†• Ïö∞ÏÑ∏Î°ú Î°±Ïù¥ Ïú†Î¶¨ÌïòÎã§"
        elif 'Í∞ïÌïú Ïàè' in signal:
            return "ÌïµÏã¨ ÏßÄÌëú Î∂ÑÏÑù Ï¢ÖÌï© ÌèâÍ∞Ä ÏöîÏïΩ: Îß§ÎèÑ ÏïïÎ†• Ï¶ùÍ∞ÄÏôÄ Í≥ºÏó¥ Ïã†Ìò∏Î°ú ÏàèÏù¥ Ïú†Î¶¨ÌïòÎã§"
        elif 'Î°±' in signal:
            return "ÌïµÏã¨ ÏßÄÌëú Î∂ÑÏÑù Ï¢ÖÌï© ÌèâÍ∞Ä ÏöîÏïΩ: Ï†ÑÎ∞òÏ†ÅÏúºÎ°ú Î°± Ïã†Ìò∏Í∞Ä Ïö∞ÏÑ∏ÌïòÎÇò Ïã†Ï§ëÌïú Ï†ëÍ∑º ÌïÑÏöî"
        elif 'Ïàè' in signal:
            return "ÌïµÏã¨ ÏßÄÌëú Î∂ÑÏÑù Ï¢ÖÌï© ÌèâÍ∞Ä ÏöîÏïΩ: Ïàè Ïã†Ìò∏Í∞Ä ÎÇòÌÉÄÎÇòÍ≥† ÏûàÏúºÎÇò Í∞ïÎèÑÎäî Î≥¥ÌÜµ ÏàòÏ§Ä"
        else:
            return "ÌïµÏã¨ ÏßÄÌëú Î∂ÑÏÑù Ï¢ÖÌï© ÌèâÍ∞Ä ÏöîÏïΩ: Î™ÖÌôïÌïú Î∞©Ìñ•ÏÑ± ÏóÜÏù¥ Ï§ëÎ¶Ω ÏÉÅÌÉú ÏßÄÏÜç"
    
    async def _format_technical_analysis(self, market_data: dict, indicators: dict) -> str:
        """Í∏∞Ïà†Ï†Å Î∂ÑÏÑù - ÏÑ†Î¨º Í¥ÄÏ†ê"""
        technical = indicators.get('technical', {})
        market_profile = indicators.get('market_profile', {})
        volume_delta = indicators.get('volume_delta', {})
        
        lines = [
            f"‚Ä¢ 24H Í≥†/Ï†Ä: ${market_data.get('high_24h', 0):,.0f} / ${market_data.get('low_24h', 0):,.0f}",
            f"‚Ä¢ 24H Î≥ÄÎèô: {market_data.get('change_24h', 0):+.1%} | Í±∞ÎûòÎüâ: {market_data.get('volume_24h', 0):,.0f} BTC"
        ]
        
        # Í±∞ÎûòÎüâ Î∂ÑÏÑù Ï∂îÍ∞Ä
        if volume_delta and volume_delta.get('signal'):
            buy_vol = volume_delta.get('buy_volume', 0)
            sell_vol = volume_delta.get('sell_volume', 0)
            if buy_vol > sell_vol * 1.1:
                lines.append("‚Ä¢ Í±∞ÎûòÎüâ Ï¶ùÍ∞Ä, Îß§Ïàò Ï≤¥Í≤∞ Ïö∞ÏÑ∏ ‚Üí Î°± ÏßÄÏßÄ")
            elif sell_vol > buy_vol * 1.1:
                lines.append("‚Ä¢ Í±∞ÎûòÎüâ Ï¶ùÍ∞Ä, Îß§ÎèÑ Ï≤¥Í≤∞ Ïö∞ÏÑ∏ ‚Üí Ïàè ÏßÄÏßÄ")
            else:
                lines.append("‚Ä¢ Í±∞ÎûòÎüâ Í∑†Ìòï ÏÉÅÌÉú")
        
        # RSI
        if 'rsi' in technical:
            rsi_data = technical['rsi']
            rsi_val = rsi_data.get('value', 50)
            if rsi_val < 40:
                lines.append(f"‚Ä¢ RSI(14): {rsi_val:.1f} ‚Üí ÏÉÅÏäπ Ïó¨Î†• Ï°¥Ïû¨")
            elif rsi_val > 60:
                lines.append(f"‚Ä¢ RSI(14): {rsi_val:.1f} ‚Üí Í≥ºÏó¥ Ï£ºÏùò")
            else:
                lines.append(f"‚Ä¢ RSI(14): {rsi_val:.1f} ‚Üí Ï§ëÎ¶Ω")
        
        # ÎßàÏºì ÌîÑÎ°úÌååÏùº
        if market_profile and 'poc' in market_profile:
            poc = market_profile['poc']
            current = market_data.get('current_price', 0)
            
            if current > poc * 1.01:
                poc_signal = "Î°± Í∞ïÏÑ∏ Ïã†Ìò∏"
            elif current < poc * 0.99:
                poc_signal = "Ïàè ÏïïÎ†• Ï¶ùÍ∞Ä"
            else:
                poc_signal = "Í∑†ÌòïÏ†ê Í∑ºÏ≤ò"
            
            lines.append(f"‚Ä¢ POC (Point of Control): ${poc:,.0f} ‚Üí {poc_signal}")
            lines.append(f"‚Ä¢ Value Area: ${market_profile['value_area_low']:,.0f} ~ ${market_profile['value_area_high']:,.0f}")
            lines.append(f"‚Ä¢ ÌòÑÏû¨ ÏúÑÏπò: {market_profile.get('price_position', 'Ï§ëÎ¶Ω')}")
        
        # Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ï¢ÖÌï©
        lines.append("")
        lines.append(self._generate_technical_summary(market_data, indicators))
        
        return '\n'.join(lines)
    
    def _generate_technical_summary(self, market_data: dict, indicators: dict) -> str:
        """Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ï¢ÖÌï© ÌèâÍ∞Ä"""
        technical = indicators.get('technical', {})
        volume_delta = indicators.get('volume_delta', {})
        
        bullish_count = 0
        bearish_count = 0
        
        # RSI Ï≤¥ÌÅ¨
        if technical.get('rsi', {}).get('signal') == 'Í≥ºÎß§ÎèÑ':
            bullish_count += 1
        elif technical.get('rsi', {}).get('signal') == 'Í≥ºÎß§Ïàò':
            bearish_count += 1
        
        # Í±∞ÎûòÎüâ Ï≤¥ÌÅ¨
        if 'Îß§Ïàò Ïö∞ÏÑ∏' in volume_delta.get('signal', ''):
            bullish_count += 1
        elif 'Îß§ÎèÑ Ïö∞ÏÑ∏' in volume_delta.get('signal', ''):
            bearish_count += 1
        
        # Í∞ÄÍ≤© ÏúÑÏπò Ï≤¥ÌÅ¨
        market_profile = indicators.get('market_profile', {})
        if 'Value Area ÌïòÎã®' in market_profile.get('price_position', ''):
            bullish_count += 1
        elif 'Value Area ÏÉÅÎã®' in market_profile.get('price_position', ''):
            bearish_count += 1
        
        if bullish_count > bearish_count:
            return "Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ï¢ÖÌï© ÌèâÍ∞Ä ÏöîÏïΩ: Ï£ºÏöî ÏßÄÌëúÎì§Ïù¥ ÏÉÅÏäπ Ïã†Ìò∏Î•º Î≥¥Ïù¥Î©∞ Î°±Ïù¥ Ïú†Î¶¨ÌïòÎã§"
        elif bearish_count > bullish_count:
            return "Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ï¢ÖÌï© ÌèâÍ∞Ä ÏöîÏïΩ: Í∏∞Ïà†Ï†Å ÏßÄÌëúÎì§Ïù¥ ÌïòÎùΩ ÏïïÎ†•ÏùÑ ÏãúÏÇ¨ÌïòÏó¨ ÏàèÏù¥ Ïú†Î¶¨ÌïòÎã§"
        else:
            return "Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ï¢ÖÌï© ÌèâÍ∞Ä ÏöîÏïΩ: Í∏∞Ïà†Ï†Å ÏßÄÌëúÎì§Ïù¥ ÌòºÏû¨ÎêòÏñ¥ Î∞©Ìñ•ÏÑ±Ïù¥ Î∂àÎ™ÖÌôïÌïòÎã§"
    
    async def _format_market_sentiment(self, market_data: dict, indicators: dict) -> str:
        """ÏãúÏû• Ïã¨Î¶¨ Î∞è Ìè¨ÏßÄÏÖîÎãù"""
        cvd = indicators.get('volume_delta', {})
        smart_money = indicators.get('smart_money', {})
        
        lines = []
        
        # CVD (ÎàÑÏ†Å Í±∞ÎûòÎüâ Îç∏ÌÉÄ)
        if cvd:
            lines.append(f"‚Ä¢ CVD: {cvd.get('cvd_ratio', 0):+.1f}% ‚Üí {cvd.get('signal', 'Í∑†Ìòï')}")
            lines.append(f"‚Ä¢ Îß§Ïàò/Îß§ÎèÑ Í±∞ÎûòÎüâ: {cvd.get('buy_volume', 0):,.0f} / {cvd.get('sell_volume', 0):,.0f} BTC")
        
        # Ïä§ÎßàÌä∏Î®∏Îãà
        if smart_money:
            lines.append(f"‚Ä¢ ÎåÄÌòï Í±∞Îûò: Îß§Ïàò {smart_money.get('large_buy_count', 0)}Í±¥ vs Îß§ÎèÑ {smart_money.get('large_sell_count', 0)}Í±¥")
            lines.append(f"‚Ä¢ Ïä§ÎßàÌä∏Î®∏Îãà ÌîåÎ°úÏö∞: {smart_money.get('net_flow', 0):+.1f} BTC ‚Üí {smart_money.get('signal', 'Ï§ëÎ¶Ω')}")
        
        # ÏãúÏû• Í∞úÏöî (CoinGecko)
        if 'market_overview' in market_data and market_data['market_overview']:
            overview = market_data['market_overview']
            lines.append(f"‚Ä¢ BTC ÎèÑÎØ∏ÎÑåÏä§: {overview.get('btc_dominance', 0):.1f}%")
            lines.append(f"‚Ä¢ Ï†ÑÏ≤¥ ÏãúÏ¥ù Î≥ÄÌôî: {overview.get('market_cap_change_24h', 0):+.1f}%")
        
        # ÏãúÏû• Ïã¨Î¶¨ Ï¢ÖÌï©
        lines.append("")
        lines.append(self._generate_sentiment_summary(indicators, market_data))
        
        return '\n'.join(lines) if lines else "‚Ä¢ ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ï§ë"
    
    def _generate_sentiment_summary(self, indicators: dict, market_data: dict) -> str:
        """ÏãúÏû• Ïã¨Î¶¨ Ï¢ÖÌï© ÌèâÍ∞Ä"""
        cvd = indicators.get('volume_delta', {})
        smart_money = indicators.get('smart_money', {})
        
        bullish_signals = 0
        bearish_signals = 0
        
        # CVD Ï≤¥ÌÅ¨
        if cvd.get('cvd_ratio', 0) > 10:
            bullish_signals += 1
        elif cvd.get('cvd_ratio', 0) < -10:
            bearish_signals += 1
        
        # Ïä§ÎßàÌä∏Î®∏Îãà Ï≤¥ÌÅ¨
        if smart_money.get('net_flow', 0) > 5:
            bullish_signals += 1
        elif smart_money.get('net_flow', 0) < -5:
            bearish_signals += 1
        
        # Fear & Greed Ï≤¥ÌÅ¨
        if 'fear_greed' in market_data and market_data['fear_greed']:
            fng_value = market_data['fear_greed'].get('value', 50)
            if fng_value > 70:
                bullish_signals += 1
            elif fng_value < 30:
                bearish_signals += 1
        
        if bullish_signals > bearish_signals:
            return "ÏãúÏû• Ïã¨Î¶¨ Ï¢ÖÌï© ÌèâÍ∞Ä ÏöîÏïΩ: Îß§Ïàò Ïã¨Î¶¨Í∞Ä Ïö∞ÏÑ∏ÌïòÏó¨ Î°±Ïù¥ Ïú†Î¶¨ÌïòÎã§"
        elif bearish_signals > bullish_signals:
            return "ÏãúÏû• Ïã¨Î¶¨ Ï¢ÖÌï© ÌèâÍ∞Ä ÏöîÏïΩ: Îß§ÎèÑ Ïã¨Î¶¨Í∞Ä Í∞ïÌï¥ ÏàèÏù¥ Ïú†Î¶¨ÌïòÎã§"
        else:
            return "ÏãúÏû• Ïã¨Î¶¨ Ï¢ÖÌï© ÌèâÍ∞Ä ÏöîÏïΩ: ÏãúÏû• Ïã¨Î¶¨Í∞Ä Ï§ëÎ¶ΩÏ†ÅÏù¥Î©∞ Í¥ÄÎßùÏÑ∏Í∞Ä Ïö∞ÏÑ∏ÌïòÎã§"
    
    def _format_trading_signals(self, indicators: dict) -> str:
        """Î°±/Ïàè Ïã†Ìò∏ Î∂ÑÏÑù"""
        composite = indicators.get('composite_signal', {})
        scores = composite.get('scores', {})
        
        lines = [
            f"üî¥ Ï¢ÖÌï© Ïã†Ìò∏: {composite.get('signal', 'Ï§ëÎ¶Ω')} (Ïã†Î¢∞ÎèÑ {composite.get('confidence', 50):.0f}%)",
            "",
            "üìä ÏÑ∏Î∂Ä Ï†êÏàò (¬±10Ï†ê):"
        ]
        
        # Ï†êÏàòÎ≥Ñ Ï†ïÎ†¨ (Ï†àÎåÄÍ∞í Í∏∞Ï§Ä)
        sorted_scores = sorted(scores.items(), key=lambda x: abs(x[1]), reverse=True)
        
        for indicator, score in sorted_scores:
            if score > 0:
                bar = "üü¢" * int(score) + "‚ö™" * (10 - int(score))
                lines.append(f"‚Ä¢ {indicator:15s}: {bar} +{score:.1f}")
            elif score < 0:
                bar = "üî¥" * int(abs(score)) + "‚ö™" * (10 - int(abs(score)))
                lines.append(f"‚Ä¢ {indicator:15s}: {bar} {score:.1f}")
            else:
                lines.append(f"‚Ä¢ {indicator:15s}: ‚ö™‚ö™‚ö™‚ö™‚ö™‚ö™‚ö™‚ö™‚ö™‚ö™ 0.0")
        
        lines.extend([
            "",
            f"üìç ÏµúÏ¢Ö Ï†êÏàò: {composite.get('total_score', 0):+.1f}/10",
            f"üìç Ï∂îÏ≤ú Ïï°ÏÖò: {composite.get('action', 'Í¥ÄÎßù')}",
            f"üìç Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞: {composite.get('position_size', 'ÌëúÏ§Ä')}"
        ])
        
        return '\n'.join(lines)
    
    async def _format_strategy_recommendation(self, market_data: dict, indicators: dict) -> str:
        """Íµ¨Ï≤¥Ï†Å Ï†ÑÎûµ Ï†úÏïà"""
        composite = indicators.get('composite_signal', {})
        signal = composite.get('signal', 'Ï§ëÎ¶Ω')
        current_price = market_data.get('current_price', 0)
        
        if self.openai_client:
            # GPT Í∏∞Î∞ò Ï†ÑÎûµ ÏÉùÏÑ±
            try:
                # Ï£ºÏöî ÏßÄÌëú ÏöîÏïΩ
                summary = {
                    'Ïã†Ìò∏': signal,
                    'Ï†êÏàò': composite.get('total_score', 0),
                    'ÌéÄÎî©ÎπÑ': indicators.get('funding_analysis', {}).get('current_rate', 0),
                    'OIÎ≥ÄÌôî': indicators.get('oi_analysis', {}).get('oi_change_percent', 0),
                    'CVD': indicators.get('volume_delta', {}).get('cvd_ratio', 0),
                    'Î¶¨Ïä§ÌÅ¨': indicators.get('risk_metrics', {}).get('risk_level', 'Î≥¥ÌÜµ')
                }
                
                prompt = f"""
ÎπÑÌä∏ÏΩîÏù∏ ÏÑ†Î¨º Ìä∏Î†àÏù¥ÎçîÎ•º ÏúÑÌïú Íµ¨Ï≤¥Ï†Å Ï†ÑÎûµÏùÑ Ï†úÏãúÌïòÏÑ∏Ïöî:

ÌòÑÏû¨ ÏÉÅÌô©:
- Í∞ÄÍ≤©: ${current_price:,.0f}
- Ï¢ÖÌï© Ïã†Ìò∏: {summary['Ïã†Ìò∏']} (Ï†êÏàò {summary['Ï†êÏàò']:.1f})
- ÌéÄÎî©ÎπÑ: {summary['ÌéÄÎî©ÎπÑ']:+.3%}
- OI Î≥ÄÌôî: {summary['OIÎ≥ÄÌôî']:+.1f}%
- CVD: {summary['CVD']:+.1f}%
- Î¶¨Ïä§ÌÅ¨: {summary['Î¶¨Ïä§ÌÅ¨']}

Îã§ÏùåÏùÑ Ìè¨Ìï®ÌïòÏó¨ 5Ï§Ñ Ïù¥ÎÇ¥Î°ú ÏûëÏÑ±:
1. ÏßÑÏûÖ Î∞©Ìñ• (Î°±/Ïàè/Í¥ÄÎßù)
2. Íµ¨Ï≤¥Ï†Å ÏßÑÏûÖÍ∞Ä Î≤îÏúÑ
3. ÏÜêÏ†àÍ∞Ä ÏÑ§Ï†ï
4. Î™©ÌëúÍ∞Ä (1Ï∞®, 2Ï∞®)
5. Ï£ºÏùòÏÇ¨Ìï≠

Î≤àÌò∏Î•º Î∂ôÏó¨ÏÑú Í∞Å Ìï≠Î™©ÏùÑ Î™ÖÌôïÌûà Íµ¨Î∂ÑÌïòÏÑ∏Ïöî.
Î†àÎ≤ÑÎ¶¨ÏßÄ Ïñ∏Í∏âÏùÄ Ï†àÎåÄ Í∏àÏßÄ
"""
                
                response = await self.openai_client.chat.completions.create(
                    model="gpt-3.5-turbo",
                    messages=[
                        {"role": "system", "content": "ÎãπÏã†ÏùÄ Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨Î•º ÏµúÏö∞ÏÑ†ÏúºÎ°ú ÌïòÎäî ÏÑ†Î¨º Ìä∏Î†àÏù¥Îî© Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§."},
                        {"role": "user", "content": prompt}
                    ],
                    max_tokens=300,
                    temperature=0.3
                )
                
                return response.choices[0].message.content.strip()
                
            except Exception as e:
                self.logger.error(f"GPT Ï†ÑÎûµ ÏÉùÏÑ± Ïã§Ìå®: {e}")
        
        # Í∑úÏπô Í∏∞Î∞ò Ï†ÑÎûµ
        if 'Í∞ïÌïú Î°±' in signal:
            return f"""1. ÏßÑÏûÖ: ÌòÑÏû¨Í∞Ä Í∑ºÏ≤ò ÎòêÎäî Îã®Í∏∞ Ï°∞Ï†ï Ïãú Î°± ÏßÑÏûÖ
2. ÏßÑÏûÖÍ∞Ä Î≤îÏúÑ: ${current_price * 0.995:,.0f} ~ ${current_price * 1.002:,.0f}
3. ÏÜêÏ†àÍ∞Ä: ${current_price * 0.985:,.0f} (-1.5%)
4. Î™©ÌëúÍ∞Ä: 1Ï∞® ${current_price * 1.015:,.0f} (+1.5%), 2Ï∞® ${current_price * 1.03:,.0f} (+3%)
5. Ï£ºÏùò: ÌéÄÎî©ÎπÑ Í≥ºÏó¥ Ïãú ÏùµÏ†à ÌÉÄÏù¥Î∞ç Ï§ëÏöî"""
        
        elif 'Í∞ïÌïú Ïàè' in signal:
            return f"""1. ÏßÑÏûÖ: ÌòÑÏû¨Í∞Ä Í∑ºÏ≤ò ÎòêÎäî Îã®Í∏∞ Î∞òÎì± Ïãú Ïàè ÏßÑÏûÖ
2. ÏßÑÏûÖÍ∞Ä Î≤îÏúÑ: ${current_price * 0.998:,.0f} ~ ${current_price * 1.005:,.0f}
3. ÏÜêÏ†àÍ∞Ä: ${current_price * 1.015:,.0f} (+1.5%)
4. Î™©ÌëúÍ∞Ä: 1Ï∞® ${current_price * 0.985:,.0f} (-1.5%), 2Ï∞® ${current_price * 0.97:,.0f} (-3%)
5. Ï£ºÏùò: Ïàè Ïä§ÌÄ¥Ï¶à Í∞ÄÎä•ÏÑ± Ìï≠ÏÉÅ ÏóºÎëê"""
        
        else:
            return f"""1. ÌòÑÏû¨ Î™ÖÌôïÌïú Î∞©Ìñ•ÏÑ± Î∂ÄÏû¨, Í¥ÄÎßù Í∂åÏû•
2. ÏÉÅÎ∞© ÎèåÌåå ÎåÄÍ∏∞: ${current_price * 1.01:,.0f} Ïù¥ÏÉÅ ÌôïÏ†ï Ïãú Î°±
3. ÌïòÎ∞© Ïù¥ÌÉà ÎåÄÍ∏∞: ${current_price * 0.99:,.0f} Ïù¥Ìïò ÌôïÏ†ï Ïãú Ïàè
4. Î™©Ìëú: ÎèåÌåå/Ïù¥ÌÉà Î∞©Ìñ•ÏúºÎ°ú 1.5~2% ÏàòÏùµ
5. Ï£ºÏùò: Î≥ÄÎèôÏÑ± ÌôïÎåÄ ÏãúÏ†êÍπåÏßÄ Ïù∏ÎÇ¥Ïã¨ ÌïÑÏöî"""
    
    def _format_risk_assessment(self, indicators: dict) -> str:
        """Î¶¨Ïä§ÌÅ¨ ÌèâÍ∞Ä"""
        risk = indicators.get('risk_metrics', {})
        liquidations = indicators.get('liquidation_analysis', {})
        
        lines = [
            f"‚Ä¢ Ï¢ÖÌï© Î¶¨Ïä§ÌÅ¨: {risk.get('risk_level', 'Î≥¥ÌÜµ')} (Ï†êÏàò {risk.get('risk_score', 0)}/10)",
            f"‚Ä¢ Î≥ÄÎèôÏÑ± Î¶¨Ïä§ÌÅ¨: {risk.get('volatility_risk', 'Î≥¥ÌÜµ')}",
            f"‚Ä¢ ÌéÄÎî©ÎπÑ Î¶¨Ïä§ÌÅ¨: {risk.get('funding_risk', 'Î≥¥ÌÜµ')}",
            f"‚Ä¢ Í∂åÏû• Ìè¨ÏßÄÏÖò: {risk.get('position_sizing', 'ÌëúÏ§Ä Ìè¨ÏßÄÏÖò')}"
        ]
        
        # Ï≤≠ÏÇ∞ Î†àÎ≤®
        if liquidations and 'long_liquidation_levels' in liquidations:
            lines.extend([
                "",
                "‚ö° Ï£ºÏöî Ï≤≠ÏÇ∞ Î†àÎ≤®:",
                f"‚Ä¢ Î°± Ï≤≠ÏÇ∞: ${liquidations['long_liquidation_levels'][0]:,.0f} (3% ÌïòÎùΩ)",
                f"‚Ä¢ Ïàè Ï≤≠ÏÇ∞: ${liquidations['short_liquidation_levels'][0]:,.0f} (3% ÏÉÅÏäπ)"
            ])
        
        return '\n'.join(lines)
    
    def _format_validation(self) -> str:
        """Ïù¥Ï†Ñ ÏòàÏ∏° Í≤ÄÏ¶ù"""
        if not self.last_prediction:
            return "‚Ä¢ Ïù¥Ï†Ñ ÏòàÏ∏° Í∏∞Î°ù ÏóÜÏùå"
        
        # Ïã§Ï†ú Í≤ÄÏ¶ù Î°úÏßÅ Íµ¨ÌòÑ ÌïÑÏöî
        return f"""‚Ä¢ {self.last_prediction.get('time', 'Ïù¥Ï†Ñ')} "{self.last_prediction.get('signal', 'Ï§ëÎ¶Ω')}" Ïã†Ìò∏
- Ïã†Î¢∞ÎèÑ: {self.last_prediction.get('confidence', 0):.0f}%
- Í≤∞Í≥º: Í≤ÄÏ¶ù ÎåÄÍ∏∞Ï§ë"""
    
    async def _format_profit_loss(self) -> str:
        """ÏÜêÏùµ ÌòÑÌô©"""
        try:
            position_info = await self._get_position_info()
            account_info = await self._get_account_info()
            today_pnl = await self._get_today_realized_pnl()
            
            lines = []
            
            # Ìè¨ÏßÄÏÖò Ï†ïÎ≥¥
            if position_info.get('has_position'):
                side = position_info.get('side')
                entry = position_info.get('entry_price', 0)
                current = position_info.get('current_price', 0)
                pnl_rate = position_info.get('pnl_rate', 0) * 100
                
                lines.append(f"‚Ä¢ ÌòÑÏû¨ Ìè¨ÏßÄÏÖò: {side} (ÏßÑÏûÖ ${entry:,.0f}, {pnl_rate:+.1f}%)")
                lines.append(f"‚Ä¢ ÎØ∏Ïã§ÌòÑ ÏÜêÏùµ: {self._format_currency(position_info.get('unrealized_pnl', 0), False)}")
            else:
                lines.append("‚Ä¢ ÌòÑÏû¨ Ìè¨ÏßÄÏÖò: ÏóÜÏùå")
            
            # Ïã§ÌòÑ ÏÜêÏùµ
            lines.extend([
                f"‚Ä¢ Ïò§Îäò Ïã§ÌòÑ: {self._format_currency(today_pnl, False)}",
                f"‚Ä¢ Í≥ÑÏ†ï ÏûîÍ≥†: ${account_info.get('total_equity', 0):,.0f}"
            ])
            
            return '\n'.join(lines)
            
        except Exception as e:
            self.logger.error(f"ÏÜêÏùµ Ìè¨Îß∑ÌåÖ Ïã§Ìå®: {e}")
            return "‚Ä¢ ÏÜêÏùµ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®"
    
    async def _generate_mental_care(self, market_data: dict, indicators: dict) -> str:
        """Î©òÌÉà ÏºÄÏñ¥ - ÏÑ†Î¨º Í±∞ÎûòÏûê ÌäπÌôî"""
        try:
            account_info = await self._get_account_info()
            position_info = await self._get_position_info()
            today_pnl = await self._get_today_realized_pnl()
            weekly_profit = await self._get_weekly_profit()
            
            # ÏãúÏû• ÏÉÅÌô© Í≥†Î†§
            signal = indicators.get('composite_signal', {}).get('signal', 'Ï§ëÎ¶Ω')
            risk_level = indicators.get('risk_metrics', {}).get('risk_level', 'Î≥¥ÌÜµ')
            
            # Í∏∞Î≥∏ Î©òÌÉà ÏºÄÏñ¥
            message = await self.mental_care.generate_profit_mental_care(
                account_info, position_info, today_pnl, weekly_profit
            )
            
            # ÏÑ†Î¨º Í±∞Îûò ÌäπÌôî Ï°∞Ïñ∏ Ï∂îÍ∞Ä
            if risk_level in ['ÎÜíÏùå', 'Îß§Ïö∞ ÎÜíÏùå']:
                message += '\n‚Äª ÌòÑÏû¨ ÏãúÏû• Î¶¨Ïä§ÌÅ¨Í∞Ä ÎÜíÏäµÎãàÎã§. Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞Î•º Ï§ÑÏù¥Í≥† ÏÜêÏ†àÏÑ†ÏùÑ ÌÉÄÏù¥Ìä∏ÌïòÍ≤å Í¥ÄÎ¶¨ÌïòÏÑ∏Ïöî.'
            elif 'Í∞ïÌïú' in signal:
                message += '\n‚Äª Î™ÖÌôïÌïú Ïã†Ìò∏Í∞Ä ÎÇòÌÉÄÎÇ¨ÏßÄÎßå, Ìï≠ÏÉÅ ÏòàÏÉÅÏπò Î™ªÌïú Î≥ÄÎèôÏóê ÎåÄÎπÑÌïòÏÑ∏Ïöî.'
            
            return message
            
        except Exception as e:
            self.logger.error(f"Î©òÌÉà ÏºÄÏñ¥ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return '"ÏÑ†Î¨º Í±∞ÎûòÎäî ÎÜíÏùÄ Î≥ÄÎèôÏÑ±Í≥ºÏùò Ïã∏ÏõÄÏûÖÎãàÎã§. Í∞êÏ†ïÏùÑ Î∞∞Ï†úÌïòÍ≥† ÏãúÏä§ÌÖúÏùÑ Îî∞Î•¥ÏÑ∏Ïöî. üìä"'
    
    def _save_prediction(self, indicators: dict):
        """ÏòàÏ∏° Ï†ÄÏû•"""
        composite = indicators.get('composite_signal', {})
        self.last_prediction = {
            'time': datetime.now().strftime('%m-%d %H:%M'),
            'signal': composite.get('signal', 'Ï§ëÎ¶Ω'),
            'score': composite.get('total_score', 0),
            'confidence': composite.get('confidence', 50),
            'action': composite.get('action', 'Í¥ÄÎßù')
        }
